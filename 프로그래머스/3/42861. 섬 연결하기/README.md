# [level 3] 섬 연결하기 - 42861 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42861) 

### 성능 요약

메모리: 4.15 MB, 시간: 0.01 ms

### 구분

코딩테스트 연습 > 탐욕법（Greedy）

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2024년 03월 21일 22:37:18

### 문제 설명

<p>n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.</p>

<p>다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.</p>

<p><strong>제한사항</strong></p>

<ul>
<li>섬의 개수 n은 1 이상 100 이하입니다.</li>
<li>costs의 길이는 <code>((n-1) * n) / 2</code>이하입니다.</li>
<li>임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다.</li>
<li>같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다.</li>
<li>모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.</li>
<li>연결할 수 없는 섬은 주어지지 않습니다.</li>
</ul>

<p><strong>입출력 예</strong></p>
<table class="table">
        <thead><tr>
<th>n</th>
<th>costs</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>4</td>
<td>[[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]]</td>
<td>4</td>
</tr>
</tbody>
      </table>
<p><strong>입출력 예 설명</strong></p>

<p>costs를 그림으로 표현하면 다음과 같으며, 이때 초록색 경로로 연결하는 것이 가장 적은 비용으로 모두를 통행할 수 있도록 만드는 방법입니다.</p>

<p><img src="https://grepp-programmers.s3.amazonaws.com/files/production/13e2952057/f2746a8c-527c-4451-9a73-42129911fe17.png" title="" alt="image.png"></p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges

### 풀이

크루스칼 알고리즘 사용.<br>
크루스칼은 무방향 가중치 그래프에서 최소신장트리를 만드는 알고리즘이다.<br>

#### 크루스칼 알고리즘 아이디어
모든 노드의 부모 초기값을 자기자신으로 세팅. 모든 노드의 랭크 초기값을 1로 세팅. 

1. 간선을 가중치 오름차 순으로 정렬함.
2. 간선 순회
3. 현재 간선의 양 끝 노드가 속한 트리의 루트를 확인함.
  - (루트를 찾는 것은 재귀로 거슬러 올라가며 부모를 찾는다. 그 과정에서 parent가 자기자신이 아니면, 찾은 root를 부모로 갱신해준다.<br> -> path compression)
  - path compression을 통해 다음에 같은 노드의 루트를 찾을 때 반복되는 과정을 없애므로 시간을 단축시킴
4. 루트가 같으면 이미 같은 트리에 있으므로 2로 돌아감.(오름차순으로 찾으므로 최소 비용이 보장됨)
5. 부모가 다르면 union 해줌. union => rank가 작거나 같은 노드의 부모를 rank가 크거나 같은 노드로 설정함.
6. 만약 rank가 같다면, 부모 노드의 rank를 1 증가시킴(트리 높이 1 증가)
  - 랭크를 사용하여 flat한 트리를 만들 수 있도록 한다. -> union by rank
  - union by rank를 통해 트리 높이를 작게 만들어서 루트를 찾는 시간을 단축시킴
7. 현재 간선을 비용에 포함시키고, 트리에 포함된 edge 수를 1 증가시킨다.
8. 만약 edge 수 = 노드 수 - 1 이라면, 최소 신장 트리를 이룬 것이므로 종료한다.




